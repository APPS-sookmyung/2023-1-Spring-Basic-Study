# 5주차

### 스프링 DB 접근 기술

- H2 데이터베이스 설치
    
    [https://www.h2database.com](https://www.h2database.com)에서 1.4.200 버전 설치 (스프링 부트 버전에 맞추기)
    
    실행: cmd에서 h2.bat(~h2/bin)
    
    데이터베이스 파일 생성 방법
    
    jdbc:h2:~/test(최초 한번)
    
    ~/test.mv.db 파일 생성 확인
    
    이후부터는 jdbc:h2:tcp://localhost/~/test 접속 (jdbc:h2:~/test 파일로 접근하면 오류 발생)
    
    테이블 생성 - 테이블 관리를 위해 프로젝트 루트에 sql/ddl.sql 파일 생성(H2)
    
    ```java
    drop table if exists member CASCADE; //없어도 됨
    create table member
    (
    	 id bigint generated by default as identity, // 값을 세팅하고 있지 않았다면 db가 들어왔을 때 자동으로 id값 채움
    	 name varchar(255),
    	 primary key (id)
    );
    ```
    
    id: java에서는 long, db에서는 bigint 타입
    
    ```java
    select * from member; // 멤버 조회(아무것도 없는 상태에서 MEMBER 클릭도 가능)
    ```
    
    ```java
    insert into member(name) values('spring') // 생성 
    ```
    
- 순수 Jdbc
    
    고대기술….
    
    - 환경 설정
    
    ```java
    // build.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    runtimeOnly 'com.h2database:h2'
    ```
    
    스프링 부트 데이터베이스 연결 설정 추가
    
    ```java
    // resources/application.properties
    spring.datasource.url=jdbc:h2:tcp://localhost/~/test
    spring.datasource.driver-class-name=org.h2.Driver
    spring.datasource.username=sa
    ```
    
    - Jdbc 리포지토리 구현
        
        Jdbc 회원 리포지토리
        
        ```java
        // 코드 생략
        ```
        
        스프링 설정 변경
        
        - 코드
            
            ```java
            package hello.hellospring;
            
            import hello.hellospring.repository.JdbcMemberRepository;
            import hello.hellospring.repository.JdbcTemplateMemberRepository;
            import hello.hellospring.repository.MemberRepository;
            import hello.hellospring.repository.MemoryMemberRepository;
            import hello.hellospring.service.MemberService;
            import org.springframework.context.annotation.Bean;
            import org.springframework.context.annotation.Configuration;
            
            import javax.sql.DataSource;
            
            @Configuration
            public class SpringConfig {
            
             private final DataSource dataSource;
            
             public SpringConfig(DataSource dataSource) {
             this.dataSource = dataSource;
             }
            
             @Bean
             public MemberService memberService() {
            	 return new MemberService(memberRepository());
             }
             
            @Bean
             public MemberRepository memberRepository() {
            // return new MemoryMemberRepository();
            	return new JdbcMemberRepository(dataSource);
             }
            }
            ```
            
        
        DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션
        정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어둔다. 그래서 DI를 받을 수 있다.
        
    
    ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20d48e8d28ddda494db0382a44a2d603b7/Untitled.png)
    
    - 개방-폐쇄 원칙(OCP, Open-Closed Principle)
        - 확장에는 열려있고, 수정, 변경에는 닫혀있다.
    - 스프링의 DI (Dependencies Injection)을 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현
    클래스를 변경할 수 있다.
    - 회원을 등록하고 DB에 결과가 잘 입력되는지 확인하자.
    - 데이터를 DB에 저장하므로 스프링 서버를 다시 실행해도 데이터가 안전하게 저장된다.
- 스프링 통합 테스트
    
    회원 서비스 통합 테스트
    
    - 코드
        
        ```java
        package hello.hellospring.service;
        
        import hello.hellospring.domain.Member;
        import hello.hellospring.repository.MemberRepository;
        import org.junit.jupiter.api.Test;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.boot.test.context.SpringBootTest;
        import org.springframework.transaction.annotation.Transactional;
        
        import static org.assertj.core.api.Assertions.assertThat;
        import static org.junit.jupiter.api.Assertions.assertEquals;
        import static org.junit.jupiter.api.Assertions.assertThrows;
        
        @SpringBootTest
        @Transactional
        class MemberServiceIntegrationTest {
        
        	 @Autowired MemberService memberService;
        	 @Autowired MemberRepository memberRepository;
        	
        	 @Test
        	 public void 회원가입() throws Exception {
        	
        		 //Given
        		 Member member = new Member();
        		 member.setName("hello");
        		
        		 //When
        		 Long saveId = memberService.join(member);
        		 
        		//Then
        		 Member findMember = memberRepository.findById(saveId).get();
        		 assertEquals(member.getName(), findMember.getName());
        	 }
        	
        	 @Test
        	 public void 중복_회원_예외() throws Exception {
        	
        		 //Given
        		 Member member1 = new Member();
        		 member1.setName("spring");
        		
        		 Member member2 = new Member();
        		 member2.setName("spring");
        		 
        		//When
        		 memberService.join(member1);
        		 IllegalStateException e = assertThrows(IllegalStateException.class,
        		 () -> memberService.join(member2));//예외가 발생해야 한다.
        		 
        		assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
        	 }
        }
        ```
        
    
    데이터 베이스는 기본적으로 트랜잭션이라는 개념이 있는데 커밋을 해야 DB에 반영이 된다.
    
    - @SpringBootTest : 스프링 컨테이너와 테스트를 함께 실행한다.
    - @Transactional : 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고,
    테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지
    않는다.
    
    순수한 단위 테스트가 좋은 테스트일 확률이 높다.
    
    단위로 쪼개서 테스트 할 수 있어야 하고 스프링 컨테이너 없이 테스트 할 수 있도록 훈련해야 한다. 
    
- 스프링 Jdbc Template
    
    순수 Jdbc와 동일한 환경설정을 하면 된다.
    스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분
    제거해준다. 하지만 SQL은 직접 작성해야 한다.
    
    스프링 JdbcTemplate 회원 리포지토리
    
    - 코드
        
        ```java
        package hello.hellospring.repository;
        
        import hello.hellospring.domain.Member;
        import org.springframework.jdbc.core.JdbcTemplate;
        import org.springframework.jdbc.core.RowMapper;
        import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
        import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
        
        import javax.sql.DataSource;
        import java.sql.ResultSet;
        import java.sql.SQLException;
        import java.util.HashMap;
        import java.util.List;
        import java.util.Map;
        import java.util.Optional;
        
        // @Autowired 생성자가 하나만 있을 때 생략 가능
        public class JdbcTemplateMemberRepository implements MemberRepository {
        
        	 private final JdbcTemplate jdbcTemplate;
        
        	 public JdbcTemplateMemberRepository(DataSource dataSource) {
        		 jdbcTemplate = new JdbcTemplate(dataSource);
        	 }
        	 @Override
        	 public Member save(Member member) {
        		 SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        		 jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");
        		 Map<String, Object> parameters = new HashMap<>();
        		 parameters.put("name", member.getName());
        		
        		 Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
        		 member.setId(key.longValue());
        		 return member;
        	 }
        	 
        	@Override
        	 public Optional<Member> findById(Long id) {
        	 List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
        		 return result.stream().findAny();
        	 } // Jdbc와 비교하면 아주 간단
        	
        	 @Override
        	 public List<Member> findAll() {
        		 return jdbcTemplate.query("select * from member", memberRowMapper());
        	 }
        	
        	 @Override
        	 public Optional<Member> findByName(String name) {
        		 List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
        		 return result.stream().findAny();
        	 }
        	
        	 private RowMapper<Member> memberRowMapper() {
        		 return (rs, rowNum) -> {
        			 Member member = new Member();
        			 member.setId(rs.getLong("id"));
        			 member.setName(rs.getString("name"));
        			 return member;
        		 };
        	 }
        }
        ```
        
    
    JdbcTemplate을 사용하도록 스프링 설정 변경
    
    - 코드
        
        ```java
        package hello.hellospring;
        
        import hello.hellospring.repository.JdbcMemberRepository;
        import hello.hellospring.repository.JdbcTemplateMemberRepository;
        import hello.hellospring.repository.MemberRepository;
        import hello.hellospring.repository.MemoryMemberRepository;
        import hello.hellospring.service.MemberService;
        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        
        import javax.sql.DataSource;
        
        @Configuration
        public class SpringConfig {
        	
        	 private final DataSource dataSource;
        	
        	 public SpringConfig(DataSource dataSource) {
        		 this.dataSource = dataSource;
        	 }
        	
        	 @Bean
        	 public MemberService memberService() {
        		 return new MemberService(memberRepository());
        	 }
        	
        	 @Bean
        	 public MemberRepository memberRepository() {
        		// return new MemoryMemberRepository();
        		// return new JdbcMemberRepository(dataSource);
        			 return new JdbcTemplateMemberRepository(dataSource);
        		}
        }
        ```